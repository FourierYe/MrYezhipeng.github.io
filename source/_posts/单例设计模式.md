---
title: 单例设计模式
date: 2019-01-29 18:44:58
tags:
---
单例设计模式 2017-12-26
大学最后一门考试终于结束了，开始继续开始敲代码了
本来这篇文章是12月份想写的，但是一直由于考试，没能写成。

设计模式的重要性
我在这里谈重要性，可能为时尚早，但是经过前段时间SSH框架的学习，我发现设计模式几乎在大神的代码里无处不在。
比如Spring的IOC就对应着工厂模式，AOP对应着代理模式，MVC框架有责任链模式。。。吹不下去了，hhh。
我觉得吧，没有设计模式的JAVA程序可能写着写着就会像结构化编程的思路上靠了。（个人体会，瞎说的）。

### 单例设计模式
单例设计模式，顾名思义就是只产生一个对象的设计方法。业务需要，只要求一个对象的场景下使用。

### 饿汉式
饿汉式——直接将引用只向单例

``` java
public class SingletonDesigin {
    public static void main(String[] args){
        /**
         * 饿汉式设计模式*/
        HungrySingleton hungrySingleton=HungrySingleton.getHungrySingleton();
        HungrySingleton hungrySingleton1=HungrySingleton.getHungrySingleton();
        System.out.println(hungrySingleton==hungrySingleton1
                ?"是同一对象"
                :"不是同一对象");
    }
}
```
程序运行结果：
我是饿汉设计模式
是同一对象
发现饿汉式能够实现单例模式。

### 懒汉式
懒汉式——通过判断引用是否为空
``` java
public class LazySingleton {
    private LazySingleton(){
        System.out.println("我是懒汉式设计模式");
    }
    /**
     * 同样的私有化构造器*/
    static LazySingleton lazySingleton=null;

    public static LazySingleton getLazySingleton() {
        /**
         * 通过判断lazySingleton引用是否只向空对象，如果为空，类的内部new一个对象。*/
        if(lazySingleton==null){
            lazySingleton=new LazySingleton();
            return lazySingleton;
        }else {
            return lazySingleton;
        }
    }
}
```
测试代码

``` java
public class SingletonDesigin {
    public static void main(String[] args){
        /**
         * 懒汉式设计模式*/
        LazySingleton lazySingleton=LazySingleton.getLazySingleton();
        LazySingleton lazySingleton1=LazySingleton.getLazySingleton();
        System.out.println(lazySingleton==lazySingleton1
                ?"是同一对象"
                :"不是同一对象");
    }
}
```
程序运行结果：
我是懒汉式设计模式
是同一对象
发现懒汉式同样能够解决问题。
但是懒汉式会有线程安全问题存在。比如：

``` java
public class LazySingleton {
    private LazySingleton(){
        System.out.println("我是懒汉式设计模式");
    }
    /**
     * 同样的私有化构造器*/
    static LazySingleton lazySingleton=null;

    public static LazySingleton getLazySingleton() throws InterruptedException {
        /**
         * 通过判断lazySingleton引用是否只向空对象，如果为空，类的内部new一个对象。*/
        if(lazySingleton==null){
            Thread.sleep(1000);
            /**
            我们将程序在这里睡眠1秒钟*/
            lazySingleton=new LazySingleton();
            return lazySingleton;
        }else {
            return lazySingleton;
        }
    }
}
```
测试程序如下

``` java
public class ManyThread extends Thread {
    @Override
    public void run() {
        try {
            System.out.println(LazySingleton.getLazySingleton().hashCode());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    public static void main(String[] args) {

        ManyThread[] mts = new ManyThread[10];
        for(int i = 0 ; i < mts.length ; i++){
            mts[i] = new ManyThread();
        }

        for (int j = 0; j < mts.length; j++) {
            mts[j].start();
        }
    }
}
```

运行结果：
我是懒汉式设计模式
1460486463
我是懒汉式设计模式
123504074…

发现当多线程操作时，存在安全隐患。我们回顾一下多线程知识，当多个线程操作同一数据时就会有不安全成分，我们通常是加锁。

``` java
public static synchronized LazySingleton  getLazySingleton() throws InterruptedException {
       /**
        * 通过判断lazySingleton引用是否只向空对象，如果为空，类的内部new一个对象。*/
       if(lazySingleton==null){
           Thread.sleep(300);
           lazySingleton=new LazySingleton();
           return lazySingleton;
       }else {
           return lazySingleton;
       }
   }
```
当加完锁后，发现对象的哈希值都是531436928，所以达到了单例要求。